/**
 * Flowtype definitions for options
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.12.1
 */

import {
          Vue,CreateElement,CombinedVueInstance
        } from './vue';
import {
          VNode,VNodeData,VNodeDirective,NormalizedScopedSlot
        } from './vnode';
declare type Constructor = {
new (...args: any[]): any,...
};export type Component<Data= DefaultData<empty>, Methods= DefaultMethods<empty>, Computed= DefaultComputed, Props= DefaultProps> = typeof Vue | FunctionalComponentOptions<Props> | ComponentOptions<empty, Data, Methods, Computed, Props>;declare interface EsModuleComponent {
default: Component<>,
} export type AsyncComponent<Data= DefaultData<empty>, Methods= DefaultMethods<empty>, Computed= DefaultComputed, Props= DefaultProps> = AsyncComponentPromise<Data, Methods, Computed, Props> | AsyncComponentFactory<Data, Methods, Computed, Props>;export type AsyncComponentPromise<Data= DefaultData<empty>, Methods= DefaultMethods<empty>, Computed= DefaultComputed, Props= DefaultProps> = (
resolve: (component: Component<Data, Methods, Computed, Props>) => void,
reject: (reason?: any) => void) => Promise<Component<> | EsModuleComponent> | void;export type AsyncComponentFactory<Data= DefaultData<empty>, Methods= DefaultMethods<empty>, Computed= DefaultComputed, Props= DefaultProps> = (
) => {
component: AsyncComponentPromise<Data, Methods, Computed, Props>,
loading?: Component<> | EsModuleComponent,
error?: Component<> | EsModuleComponent,
delay?: number,
timeout?: number,...
};
/**
 * When the `Computed` type parameter on `ComponentOptions` is inferred,
 * it should have a property with the return type of every get-accessor.
 * Since there isn't a way to query for the return type of a function, we allow TypeScript
 * to infer from the shape of `Accessors<Computed>` and work backwards.
 */
export type Accessors<T> = $ObjMapi<T, <K>(K) => (() => $ElementType<T, K>) | ComputedOptions<$ElementType<T, K>>>;declare type DataDef<Data, Props, V> = Data | (() => Data);
/**
 * This type should be used when an array of strings is used for a component's `props` value.
 */
export type ThisTypedComponentOptionsWithArrayProps<V: Vue, Data, Methods, Computed, PropNames: string> = {[key: string]: any} & ComponentOptions<V, DataDef<Data, {[key: PropNames]: any, ...}, V>, Methods, Computed, PropNames[], {[key: PropNames]: any, ...}> & ThisType<CombinedVueInstance<V, Data, Methods, Computed, $ReadOnly<{[key: PropNames]: any, ...}>>>;
/**
 * This type should be used when an object mapped to `PropOptions` is used for a component's `props` value.
 */
export type ThisTypedComponentOptionsWithRecordProps<V: Vue, Data, Methods, Computed, Props> = {[key: string]: any} & ComponentOptions<V, DataDef<Data, Props, V>, Methods, Computed, RecordPropsDefinition<Props>, Props> & ThisType<CombinedVueInstance<V, Data, Methods, Computed, $ReadOnly<Props>>>;declare type DefaultData<V> = {[key: string]: any} | (() => {[key: string]: any});declare type DefaultProps = {[key: string]: any, ...};declare type DefaultMethods<V> = {
[key: string]: (...args: any[]) => any,...
};declare type DefaultComputed = {
[key: string]: any,...
};export interface ComponentOptions<V: Vue, Data= DefaultData<V>, Methods= DefaultMethods<V>, Computed= DefaultComputed, PropsDef= PropsDefinition<DefaultProps>, Props= DefaultProps> {
data?: Data,
props?: PropsDef,
propsData?: {[key: string]: any},
computed?: Accessors<Computed>,
methods?: Methods,
watch?: {[key: string]: WatchOptionsWithHandler<any> | WatchHandler<any> | string, ...},
el?: Element | string,
template?: string,
render?: (createElement: CreateElement, hack: RenderContext<Props>) => VNode,
renderError?: (createElement: CreateElement, err: Error) => VNode,
staticRenderFns?: ((createElement: CreateElement) => VNode)[],
beforeCreate?: () => void,
created?: () => void,
beforeDestroy?: () => void,
destroyed?: () => void,
beforeMount?: () => void,
mounted?: () => void,
beforeUpdate?: () => void,
updated?: () => void,
activated?: () => void,
deactivated?: () => void,
errorCaptured?: (err: Error, vm: Vue, info: string) => boolean | void,
serverPrefetch?: () => Promise<void>,
directives?: {
[key: string]: DirectiveFunction | DirectiveOptions,...
},
components?: {
[key: string]: Component<any, any, any, any> | AsyncComponent<any, any, any, any>,...
},
transitions?: {
[key: string]: {[key: string]: any},...
},
filters?: {
[key: string]: Function,...
},
provide?: {[key: string]: any} | (() => {[key: string]: any}),
inject?: InjectOptions,
model?: {
prop?: string,
event?: string,...
},
parent?: Vue,
mixins?: (ComponentOptions<Vue> | typeof Vue)[],
name?: string,
extends?: ComponentOptions<Vue> | typeof Vue,
delimiters?: [string, string],
comments?: boolean,
inheritAttrs?: boolean,
} export interface FunctionalComponentOptions<Props= DefaultProps, PropDefs= PropsDefinition<Props>> {
name?: string,
props?: PropDefs,
model?: {
prop?: string,
event?: string,...
},
inject?: InjectOptions,
functional: boolean,
render?: (createElement: CreateElement, context: RenderContext<Props>) => VNode | VNode[],
} export interface RenderContext<Props= DefaultProps> {
props: Props,
children: VNode[],
slots(): any,
data: VNodeData,
parent: Vue,
listeners: {
[key: string]: Function | Function[],...
},
scopedSlots: {
[key: string]: NormalizedScopedSlot,...
},
injections: any,
} export type Prop<T> = {
(): T,...
} | {
new (...args: empty[]): T & {[key: string]: any},...
} | {
new (...args: string[]): Function,...
};export type PropType<T> = Prop<T> | Prop<T>[];export type PropValidator<T> = PropOptions<T> | PropType<T>;export interface PropOptions<T= any> {
type?: PropType<T>,
required?: boolean,
default?: T | null | void | (() => T | null | void),
validator?: (value: T) => boolean,
} export type RecordPropsDefinition<T> = $ObjMapi<T, <K>(K) => PropValidator<$ElementType<T, K>>>;export type ArrayPropsDefinition<T> = ($Keys<T>)[];export type PropsDefinition<T> = ArrayPropsDefinition<T> | RecordPropsDefinition<T>;export interface ComputedOptions<T> {
get?: () => T,
set?: (value: T) => void,
cache?: boolean,
} export type WatchHandler<T> = (val: T, oldVal: T) => void;export interface WatchOptions {
deep?: boolean,
immediate?: boolean,
} export type WatchOptionsWithHandler<T> = {
handler: WatchHandler<T>,...
} & WatchOptions
export type DirectiveBinding = {
+modifiers: {
[key: string]: boolean,...
},...
} export type DirectiveFunction = (
el: HTMLElement,
binding: DirectiveBinding,
vnode: VNode,
oldVnode: VNode) => void;export interface DirectiveOptions {
bind?: DirectiveFunction,
inserted?: DirectiveFunction,
update?: DirectiveFunction,
componentUpdated?: DirectiveFunction,
unbind?: DirectiveFunction,
} export type InjectKey = string | Symbol;export type InjectOptions = {
[key: string]: InjectKey | {
from?: InjectKey,
default?: any,...
},...
} | string[];